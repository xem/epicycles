<style>
    body {
        margin: 0;
        overflow: hidden;
    }
</style>
<canvas id=a style="position: absolute"></canvas>
<script>
d = document;
c = a.getContext("2d");
a.width = innerWidth;
a.height = innerHeight;


// Vars / functions:

// D: draw multiple paths (default: 1)
// e: function param
// f(e): (if e.x & y are set: add a point in p, update Q) then reset P and Z, compute points FFT and gears data
// g: current gear
// i, j: loop vars
// p: points
// P: points, transformed by FFT
// m: mouse down flag
// Q: number of gears drawn (default: max)
// T: time
// U, V: current gear coordinates
// Z: points of the paths traced by each gear


// Events:

// mousedown: set m
// mousemove: if m: add a point, reset path, recompute gears
// mouseup: add a point, reset path, recompute gears
// keydown: left = toggle multiple lines / up = clear path + add a gear / right = clear all, down = clear path + remove a gear



// Code temporarly put aside:

// console.log(JSON.stringify(p));

// onmousedown = e => m = 1;
//onmousemove = e => m && f(e);
//onmouseup = e => m = f(e);

// Math.hypot(e.x - a.width / 2 - p[p.length - 1][0], e.y - a.height / 2 - p[p.length - 1][1]) > 9)


/* GOLF */

p = [];

for(i of"@DGCBCGDPHIRSKWTQTW[XZ]Z_Z[SRIHHH") p.push([50 * (i.charCodeAt() >> 2) - 950, 50 * (i.charCodeAt() & 3) - 90]);

onmousedown = e => m = 1;

onmousemove = e => m && f(p.push([e.x  - a.width / 2, e.y - a.height / 2]));

onmouseup = e => m = f(p.push([e.x  - a.width / 2, e.y - a.height / 2]));

onkeydown = e => [
  e => Q--,
  e => D ^= 1,
  e => Q++,
  e => f(p = [], G = [])
][e.which % 4]();

f = e => {

  P = p.map(e => [...e]);
  
  Z = [];
  
  for (i = 0; P.length > 2**(Math.log2(P.length) | 0); i += 2)
    P.splice(i + 1, 0, [(P[i][0] + P[i + 1][0]) / 2, (P[i][1] + P[i + 1][1]) / 2]);

  for (I in P) {
    for (A = J = D = T = 0; P.length >> A + 1; A++)
      J = J * 2 | (I >> A & 1);
    J > I && ([P[I][0], P[J][0], P[I][1], P[J][1]] = [P[J][0], P[I][0], P[J][1], P[I][1]])
  }

  for (H = 1; H * 2 <= P.length; H *= 2)
    for (I = 0; I < P.length; I += H * 2)
      for (J = I; J < I + H; J++)
        E = P[J + H][0] * Math.cos(Math.PI * (J - I) / H) + P[J + H][1] * Math.sin(Math.PI * (J - I) / H),
        M = P[J + H][1] * Math.cos(Math.PI * (J - I) / H) -P[J + H][0] * Math.sin(Math.PI * (J - I) / H),
        P[J + H][0] = P[J][0] - E,
        P[J + H][1] = P[J][1] - M,
        P[J][0] += E,
        P[J][1] += M;

  for (I = P.length, G = []; I--;)
    G.push(
      [
        I + P.length / 2 - P.length,
        Math.hypot(P[(I + P.length / 2)%P.length][0], P[(I + P.length / 2) % P.length][1]) / P.length,
        Math.atan2(P[(I + P.length / 2)%P.length][1], P[(I + P.length / 2) % P.length][0])
      ]
    );
  
  G.sort((i, B) => B[1] - i[1]);
  
  Q = P.length - 1
};

f();

setInterval(
e => {
  
  T += .01;
  a.width ^= U = V = g = 0;
  c.translate(a.width / 2, a.height / 2);
  
  for (i of p)
    c.fillRect(i[0], i[1], 2, 2);
    
  for (i of G){
    c.beginPath();
    c.arc(U, V, i[1], 0, 7);
    c.moveTo(U, V);
    U += i[1] * Math.cos(i[0] * T + i[2]);
    V += i[1] * Math.sin(i[0] * T + i[2]);
    c.lineTo(U, V);
    g <= Q && c.stroke();
      
    Z[g] = Z[g] || [];
    Z[g].length < 650 && Z[g].push([U,V]);
    g++
  }

  g = 0;
  for (i of G){
    c.beginPath();
    c.lineWidth = 5,
    c.strokeStyle = `hsl(${(Q-g)*9},50%,50%`,
    c.moveTo(Z[g][0], Z[g][1]);
    for(j of Z[g])
      (g == Math.min(Q, P.length - 1) || D && g && g <= Q && g % 16 < 1) && c.lineTo(j[0], j[1]);
    c.stroke();
    g++
  }
},
9)

/* END GOLF */
</script>
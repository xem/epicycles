<body id=b>
<style>
    body {
        margin: 0;
        overflow: hidden;
    }
</style>
<canvas id=a style="position: absolute"></canvas>
<script>
d = document;
c = a.getContext("2d");
a.width = innerWidth;
a.height = innerHeight;


// Vars / functions:

// D: draw multiple paths (default: 1)
// e: function param
// f(e): (if e.x & y are set: add a point in p, update Q) then reset P and Z, compute points FFT and gears data
// g: current gear
// i, j: loop vars
// p: points
// P: points, transformed by FFT
// m: mouse down flag
// Q: number of gears drawn (default: max)
// T: time
// U, V: current gear coordinates
// Z: points of the paths traced by each gear


// Events:

// mousedown: set m
// mousemove: if m: add a point, reset path, recompute gears
// mouseup: add a point, reset path, recompute gears
// keydown: left = toggle multiple lines / up = clear path + add a gear / right = clear all, down = clear path + remove a gear



// Code temporarly put aside:

// console.log(JSON.stringify(p));

// onmousedown = e => m = 1;
//onmousemove = e => m && f(e);
//onmouseup = e => m = f(e);

// Math.hypot(e.x - a.width / 2 - p[p.length - 1][0], e.y - a.height / 2 - p[p.length - 1][1]) > 9)


/* GOLF */

p = [];

m = 0;

for(i of"@DGCBCGDPHIRSKWTQTW[XZ]Z_Z[SRIHHH") p.push([50 * (i.charCodeAt() >> 2) - 950, 50 * (i.charCodeAt() & 3) - 90]);

onmousedown = e => m = 1;

onmousemove = e => m && f(e);

onmouseup = e => (m = 0, f(e));

onkeydown = e => [
  e => D ^= 1,
  e => Q++,
  e => (p = [], G = [], f()),
  e => Q--
][e.which - 37]();

f = e => {

  e 
  &&
  (!p.length || Math.hypot(
    e.x - a.width / 2 - p[p.length - 1][0],
    e.y - a.height / 2 - p[p.length - 1][1]
  ) > 9)
  &&
  p.push([e.x - a.width / 2, e.y - a.height / 2]);
  
  P = p.map(e => [...e]);
  
  Z = [];
  
  for (b.bgColor = i = D = T = 0; P.length > 2 ** (Math.log2(P.length) | 0); i += 2)
    P.splice(i + 1, 0, [(P[i][0] + P[i + 1][0]) / 2, (P[i][1] + P[i + 1][1]) / 2]);

  _ = [];

  for (i in P) {
      _[i] = [0, 0];
      for (k in P)
          _[i][0] += (P[k][0] * Math.cos(k * -2 * Math.PI * i / P.length) - P[k][1] * Math.sin(k * -2 * Math.PI * i / P.length)),
          _[i][1] += (P[k][0] * Math.sin(k * -2 * Math.PI * i / P.length) + P[k][1] * Math.cos(k * -2 * Math.PI * i / P.length));
  }

  P = _;

  if(P.length)
  for (I = P.length, G = []; I--;)
    G.push(
      [
        I + P.length / 2 - P.length,
        Math.hypot(P[(I + P.length / 2) % P.length][0], P[(I + P.length / 2) % P.length][1]) / P.length,
        Math.atan2(P[(I + P.length / 2) % P.length][1], P[(I + P.length / 2) % P.length][0])
      ]
    );
  
  G.sort((i, B) => B[1] - i[1]);
  
  Q = P.length - 1
};

f();

setInterval(
e => {
  
  T += .01;
  a.width ^= U = V = g = 0;
  c.translate(a.width / 2, a.height / 2);
  c.strokeStyle = `#fff`;
  
  for (i of p)
    c.beginPath(),
    c.arc(i[0], i[1], 1, 0, 7),
    c.stroke();
    
  for (i of G){
    c.beginPath();
    c.arc(U, V, i[1], 0, 7);
    c.moveTo(U, V);
    U += i[1] * Math.cos(i[0] * T + i[2]);
    V += i[1] * Math.sin(i[0] * T + i[2]);
    c.lineTo(U, V);
    g <= Q && c.stroke();
      
    Z[g] = Z[g] || [];
    Z[g].length < 650 && Z[g].push([U,V]);
    g++
  }

  g = 0;
  for (i of G){
    c.beginPath();
    c.lineWidth = 5,
    c.strokeStyle = `hsl(${(Q-g)*9},50%,50%`,
    c.moveTo(Z[g][0], Z[g][1]);
    for(j of Z[g])
      (g == Math.min(Q, P.length - 1) || D && g && g <= Q && g % 8 < 1) && c.lineTo(j[0], j[1]);
    c.stroke();
    g++
  }
},
9)

/* END GOLF */
</script>
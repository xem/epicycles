<!doctype html>
<body>
<div class="example epicycle-display"
data-points="700500500500500700500500300500500500500300500500"
data-name="custom" data-editable="true"
data-autoplay="false"
data-simulator-controls="true" data-grid-controls="true" data-share-controls="false"
data-show-grid="true"
data-show-points="true">
</div>


<script>

// FFT
/* Copyright (c) 2012, Jens Nockert <jens@ofmlabs.org>, Jussi Kalliokoski <jussi@ofmlabs.org>
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met: 
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

if (!FFT) {
	var FFT = {}
}

void function (namespace) {
	"use strict"
	
	function butterfly2(output, outputOffset, outputStride, fStride, state, m) {
		var t = state.twiddle
		
		for (var i = 0; i < m; i++) {
			var s0_r = output[2 * ((outputOffset) + (outputStride) * (i))], s0_i = output[2 * ((outputOffset) + (outputStride) * (i)) + 1]
			var s1_r = output[2 * ((outputOffset) + (outputStride) * (i + m))], s1_i = output[2 * ((outputOffset) + (outputStride) * (i + m)) + 1]
			
			var t1_r = t[2 * ((0) + (fStride) * (i))], t1_i = t[2 * ((0) + (fStride) * (i)) + 1]
			
			var v1_r = s1_r * t1_r - s1_i * t1_i, v1_i = s1_r * t1_i + s1_i * t1_r
			
			var r0_r = s0_r + v1_r, r0_i = s0_i + v1_i
			var r1_r = s0_r - v1_r, r1_i = s0_i - v1_i
			
			output[2 * ((outputOffset) + (outputStride) * (i))] = r0_r, output[2 * ((outputOffset) + (outputStride) * (i)) + 1] = r0_i
			output[2 * ((outputOffset) + (outputStride) * (i + m))] = r1_r, output[2 * ((outputOffset) + (outputStride) * (i + m)) + 1] = r1_i
		}
	}
	
	function butterfly3(output, outputOffset, outputStride, fStride, state, m) {
		var t = state.twiddle
		var m1 = m, m2 = 2 * m
		var fStride1 = fStride, fStride2 = 2 * fStride
		
		var e = t[2 * ((0) + (fStride) * (m)) + 1]
		
		for (var i = 0; i < m; i++) {
			var s0_r = output[2 * ((outputOffset) + (outputStride) * (i))], s0_i = output[2 * ((outputOffset) + (outputStride) * (i)) + 1]
			
			var s1_r = output[2 * ((outputOffset) + (outputStride) * (i + m1))], s1_i = output[2 * ((outputOffset) + (outputStride) * (i + m1)) + 1]
			var t1_r = t[2 * ((0) + (fStride1) * (i))], t1_i = t[2 * ((0) + (fStride1) * (i)) + 1]
			var v1_r = s1_r * t1_r - s1_i * t1_i, v1_i = s1_r * t1_i + s1_i * t1_r
			
			var s2_r = output[2 * ((outputOffset) + (outputStride) * (i + m2))], s2_i = output[2 * ((outputOffset) + (outputStride) * (i + m2)) + 1]
			var t2_r = t[2 * ((0) + (fStride2) * (i))], t2_i = t[2 * ((0) + (fStride2) * (i)) + 1]
			var v2_r = s2_r * t2_r - s2_i * t2_i, v2_i = s2_r * t2_i + s2_i * t2_r
			
			var i0_r = v1_r + v2_r, i0_i = v1_i + v2_i
			
			var r0_r = s0_r + i0_r, r0_i = s0_i + i0_i
			output[2 * ((outputOffset) + (outputStride) * (i))] = r0_r, output[2 * ((outputOffset) + (outputStride) * (i)) + 1] = r0_i
			
			var i1_r = s0_r - i0_r * 0.5
			var i1_i = s0_i - i0_i * 0.5
			
			var i2_r = (v1_r - v2_r) * e
			var i2_i = (v1_i - v2_i) * e
			
			var r1_r = i1_r - i2_i
			var r1_i = i1_i + i2_r
			output[2 * ((outputOffset) + (outputStride) * (i + m1))] = r1_r, output[2 * ((outputOffset) + (outputStride) * (i + m1)) + 1] = r1_i
			
			var r2_r = i1_r + i2_i
			var r2_i = i1_i - i2_r
			output[2 * ((outputOffset) + (outputStride) * (i + m2))] = r2_r, output[2 * ((outputOffset) + (outputStride) * (i + m2)) + 1] = r2_i
		}
	}
	
	function butterfly4(output, outputOffset, outputStride, fStride, state, m) {
		var t = state.twiddle
		var m1 = m, m2 = 2 * m, m3 = 3 * m
		var fStride1 = fStride, fStride2 = 2 * fStride, fStride3 = 3 * fStride
		
		for (var i = 0; i < m; i++) {
			var s0_r = output[2 * ((outputOffset) + (outputStride) * (i))], s0_i = output[2 * ((outputOffset) + (outputStride) * (i)) + 1]
			
			var s1_r = output[2 * ((outputOffset) + (outputStride) * (i + m1))], s1_i = output[2 * ((outputOffset) + (outputStride) * (i + m1)) + 1]
			var t1_r = t[2 * ((0) + (fStride1) * (i))], t1_i = t[2 * ((0) + (fStride1) * (i)) + 1]
			var v1_r = s1_r * t1_r - s1_i * t1_i, v1_i = s1_r * t1_i + s1_i * t1_r
			
			var s2_r = output[2 * ((outputOffset) + (outputStride) * (i + m2))], s2_i = output[2 * ((outputOffset) + (outputStride) * (i + m2)) + 1]
			var t2_r = t[2 * ((0) + (fStride2) * (i))], t2_i = t[2 * ((0) + (fStride2) * (i)) + 1]
			var v2_r = s2_r * t2_r - s2_i * t2_i, v2_i = s2_r * t2_i + s2_i * t2_r
			
			var s3_r = output[2 * ((outputOffset) + (outputStride) * (i + m3))], s3_i = output[2 * ((outputOffset) + (outputStride) * (i + m3)) + 1]
			var t3_r = t[2 * ((0) + (fStride3) * (i))], t3_i = t[2 * ((0) + (fStride3) * (i)) + 1]
			var v3_r = s3_r * t3_r - s3_i * t3_i, v3_i = s3_r * t3_i + s3_i * t3_r
			
			var i0_r = s0_r + v2_r, i0_i = s0_i + v2_i
			var i1_r = s0_r - v2_r, i1_i = s0_i - v2_i
			var i2_r = v1_r + v3_r, i2_i = v1_i + v3_i
			var i3_r = v1_r - v3_r, i3_i = v1_i - v3_i
			
			var r0_r = i0_r + i2_r, r0_i = i0_i + i2_i
			
			if (state.inverse) {
				var r1_r = i1_r - i3_i
				var r1_i = i1_i + i3_r
			} else {
				var r1_r = i1_r + i3_i
				var r1_i = i1_i - i3_r
			}
			
			var r2_r = i0_r - i2_r, r2_i = i0_i - i2_i
			
			if (state.inverse) {
				var r3_r = i1_r + i3_i
				var r3_i = i1_i - i3_r
			} else {
				var r3_r = i1_r - i3_i
				var r3_i = i1_i + i3_r
			}
			
			output[2 * ((outputOffset) + (outputStride) * (i))] = r0_r, output[2 * ((outputOffset) + (outputStride) * (i)) + 1] = r0_i
			output[2 * ((outputOffset) + (outputStride) * (i + m1))] = r1_r, output[2 * ((outputOffset) + (outputStride) * (i + m1)) + 1] = r1_i
			output[2 * ((outputOffset) + (outputStride) * (i + m2))] = r2_r, output[2 * ((outputOffset) + (outputStride) * (i + m2)) + 1] = r2_i
			output[2 * ((outputOffset) + (outputStride) * (i + m3))] = r3_r, output[2 * ((outputOffset) + (outputStride) * (i + m3)) + 1] = r3_i
		}
	}
	
	function butterfly(output, outputOffset, outputStride, fStride, state, m, p) {
		var t = state.twiddle, n = state.n, scratch = new Float64Array(2 * p)
		
		for (var u = 0; u < m; u++) {
			for (var q1 = 0, k = u; q1 < p; q1++, k += m) {
				var x0_r = output[2 * ((outputOffset) + (outputStride) * (k))], x0_i = output[2 * ((outputOffset) + (outputStride) * (k)) + 1]
				scratch[2 * (q1)] = x0_r, scratch[2 * (q1) + 1] = x0_i
			}
			
			for (var q1 = 0, k = u; q1 < p; q1++, k += m) {
				var tOffset = 0
				
				var x0_r = scratch[2 * (0)], x0_i = scratch[2 * (0) + 1]
				output[2 * ((outputOffset) + (outputStride) * (k))] = x0_r, output[2 * ((outputOffset) + (outputStride) * (k)) + 1] = x0_i
				
				for (var q = 1; q < p; q++) {
					tOffset = (tOffset + fStride * k) % n
					
					var s0_r = output[2 * ((outputOffset) + (outputStride) * (k))], s0_i = output[2 * ((outputOffset) + (outputStride) * (k)) + 1]
					
					var s1_r = scratch[2 * (q)], s1_i = scratch[2 * (q) + 1]
					var t1_r = t[2 * (tOffset)], t1_i = t[2 * (tOffset) + 1]
					var v1_r = s1_r * t1_r - s1_i * t1_i, v1_i = s1_r * t1_i + s1_i * t1_r
					
					var r0_r = s0_r + v1_r, r0_i = s0_i + v1_i
					output[2 * ((outputOffset) + (outputStride) * (k))] = r0_r, output[2 * ((outputOffset) + (outputStride) * (k)) + 1] = r0_i
				}
			}
		}
	}
	
	function work(output, outputOffset, outputStride, f, fOffset, fStride, inputStride, factors, state) {
		var p = factors.shift()
		var m = factors.shift()
		
		if (m == 1) {
			for (var i = 0; i < p * m; i++) {
				var x0_r = f[2 * ((fOffset) + (fStride * inputStride) * (i))], x0_i = f[2 * ((fOffset) + (fStride * inputStride) * (i)) + 1]
				output[2 * ((outputOffset) + (outputStride) * (i))] = x0_r, output[2 * ((outputOffset) + (outputStride) * (i)) + 1] = x0_i
			}
		} else {
			for (var i = 0; i < p; i++) {
				work(output, outputOffset + outputStride * i * m, outputStride, f, fOffset + i * fStride * inputStride, fStride * p, inputStride, factors.slice(), state)
			}
		}
		
		switch (p) {
			case 2: butterfly2(output, outputOffset, outputStride, fStride, state, m); break
			case 3: butterfly3(output, outputOffset, outputStride, fStride, state, m); break
			case 4: butterfly4(output, outputOffset, outputStride, fStride, state, m); break
			default: butterfly(output, outputOffset, outputStride, fStride, state, m, p); break
		}
	}
	
	var complex = function (n, inverse) {
		var n = ~~n, inverse = !!inverse
		
		if (n < 1) {
			throw new RangeError("n is outside range, should be positive integer, was `" + n + "'")
		}
		
		var state = {
			n: n,
			inverse: inverse,
			
			factors: [],
			twiddle: new Float64Array(2 * n),
			scratch: new Float64Array(2 * n)
		}
		
		var t = state.twiddle, theta = 2 * Math.PI / n
		
		for (var i = 0; i < n; i++) {
			if (inverse) {
				var phase =  theta * i
			} else {
				var phase = -theta * i
			}
			
			t[2 * (i)] = Math.cos(phase)
			t[2 * (i) + 1] = Math.sin(phase)
		}
		
		var p = 4, v = Math.floor(Math.sqrt(n))
		
		while (n > 1) {
			while (n % p) {
				switch (p) {
					case 4: p = 2; break
					case 2: p = 3; break
					default: p += 2; break
				}
				
				if (p > v) {
					p = n
				}
			}
			
			n /= p
			
			state.factors.push(p)
			state.factors.push(n)
		}
		
		this.state = state
	}
	
	complex.prototype.simple = function (output, input, t) {
		this.process(output, 0, 1, input, 0, 1, t)
	}
	
	complex.prototype.process = function(output, outputOffset, outputStride, input, inputOffset, inputStride, t) {
		var outputStride = ~~outputStride, inputStride = ~~inputStride
		
		var type = t == 'real' ? t : 'complex'
		
		if (outputStride < 1) {
			throw new RangeError("outputStride is outside range, should be positive integer, was `" + outputStride + "'")
		}
		
		if (inputStride < 1) {
			throw new RangeError("inputStride is outside range, should be positive integer, was `" + inputStride + "'")
		}
		
		if (type == 'real') {
			for (var i = 0; i < this.state.n; i++) {
				var x0_r = input[inputOffset + inputStride * i]
				var x0_i = 0.0
				
				this.state.scratch[2 * (i)] = x0_r, this.state.scratch[2 * (i) + 1] = x0_i
			}
			
			work(output, outputOffset, outputStride, this.state.scratch, 0, 1, 1, this.state.factors.slice(), this.state)
		} else {
			if (input == output) {
				work(this.state.scratch, 0, 1, input, inputOffset, 1, inputStride, this.state.factors.slice(), this.state)
				
				for (var i = 0; i < this.state.n; i++) {
					var x0_r = this.state.scratch[2 * (i)], x0_i = this.state.scratch[2 * (i) + 1]
					
					output[2 * ((outputOffset) + (outputStride) * (i))] = x0_r, output[2 * ((outputOffset) + (outputStride) * (i)) + 1] = x0_i
				}
			} else {
				work(output, outputOffset, outputStride, input, inputOffset, 1, inputStride, this.state.factors.slice(), this.state)
			}
		}
	}
	
	namespace.complex = complex
}(FFT)






/*
Functions for calculating the epicycle parameters
to fit a given set of points. Based on mapping the points
into the complex domain and them applying a discrete Fourier transform.
*/

epicycles = {};

//Note, the coeffs returned are _not_ normalized
epicycles.fft = function(points) {
    if (!FFT) {
        throw new Error("Must include fft.js");
    }
    //points is an array of pairs [x, y] to be treated as complex coordinates
    //(x, y) => x + yj
    var n = points.length;
    var input = new Float64Array(2 * n), output = new Float64Array(2 * n);
    var fft = new FFT.complex(n, false);
    for (var i = 0; i < n; i++) {
        input[2*i] = points[i][0];
        input[2*i + 1] = points[i][1];
    }
    fft.simple(output, input, "complex");
    //return array of pairs
    var ret = [];
    for (var i = 0; i < n; i++) {
        ret.push([output[2*i], output[2*i+1]]);
    }
    return ret;
};

epicycles.calculateGears = function(points, maxNumber, unidirectional) {
    maxNumber = maxNumber || points.length;
    unidirectional = !!unidirectional;

    var coeffs = epicycles.fft(points);
    var n = coeffs.length;
    var e = 1e-6;
    var gears = [];

    var addGear = function(omega, coords) {
        var mag = coords[0]/n;
        if (mag > e) {
            gears.push([omega, mag, coords[1]]);
        }
    };

    if (unidirectional) {
        for (var i = 1; i < n; i++) {
            addGear(i, epicycles.toPolar(coeffs[i]));
        }
    } else {
        for (var i = 1; i <= n/2; i++) {
            //positive gear
            addGear(i, epicycles.toPolar(coeffs[i]));

            if (i == n - i) { 
                //midway case
                continue;
            }
            //negative gear, coefficients are periodic in n
            addGear(-i, epicycles.toPolar(coeffs[n - i]));
        }
    }
    //sort by magnitude
    gears.sort(function(a, b) {
        return b[1] - a[1];
    });

    //find the most significent (largest length) gears so
    //that we're <= maxNumber
    if (gears.length > maxNumber) {
       gears = gears.slice(0, maxNumber); 
    }

    //you get the "0" gear for free, if it's interesting
    var coords = epicycles.toPolar(coeffs[0]);
    if (coords[0]/n > e) {
        //add to beginning
        gears.unshift([0, coords[0]/n, coords[1]]);
    }
    console.log(JSON.stringify(points), maxNumber, JSON.stringify(gears));
    return gears;
};

epicycles.toPolar = function(rect) {
    var a = rect[0], b = rect[1];
    return [Math.sqrt(a*a + b*b), Math.atan2(b,a)];
}






/*drawing functions*/
//Nomenclature: X and Y are in Grid coordinate system, u and v are in context coordinate system
function Grid(canvas, scale) {
    this.scale = scale || 10;
    this.canvas = canvas;
    this.context = canvas.getContext('2d');
    this.width = canvas.width;
    this.height = canvas.height;

    this.originU = canvas.width/2;
    this.originV = canvas.height/2;

    this.path = [];

    this.showAxes = true;
    this.showGrid = true;

    this.drawGrid();
};

Grid.prototype.drawGrid = function() {
    var ctx = this.context;
    ctx.strokeStyle = "#000000";
    ctx.beginPath();

    //Axes
    if (this.showAxes) {
        ctx.moveTo(this.originU, 0);
        ctx.lineTo(this.originU, this.height);
        ctx.moveTo(0, this.originV);
        ctx.lineTo(this.width, this.originV);
    }

    if (this.showGrid) {
        var grid = this;
        var plusSign = function(u, v) {
            //should always be same size relative to grid
            size = 5;
            ctx.moveTo(u - size, v);
            ctx.lineTo(u + size, v);
            ctx.moveTo(u, v - size);
            ctx.lineTo(u, v + size);
        };

        for (var x = 0; (x * this.scale) + this.originU < this.width; x++) {
            for (var y = 0; (y * this.scale) + this.originV < this.height; y++) {
                //All 4 intersections [we double up on the axes, but who cares]
                plusSign(x * this.scale + this.originU, y * this.scale + this.originV);
                plusSign(-x * this.scale + this.originU, y * this.scale + this.originV);
                plusSign(x * this.scale + this.originU, -y * this.scale + this.originV);
                plusSign(-x * this.scale + this.originU, -y * this.scale + this.originV);
            }
        }
    }

    this.context.stroke();
};

Grid.prototype.drawLabeledPoint = function(point, label) {
    this.drawPoint(point);
    var uvPoint = this.transform(point);
    //offset down and to the right
    this.context.fillText(label, uvPoint[0] + 5, uvPoint[1] + 10);
};

Grid.prototype.drawPoint = function(point, size, color) {
    var uvSize = size || 4; //points should always be the same size relative to grid
    color = color || "#000000";
    this.context.beginPath();
    this.context.fillStyle = color;
    var uvPoint = this.transform(point);
    var u = uvPoint[0];
    var v = uvPoint[1];
    /*x, y, radius, startAngle, endAngle*/
    this.context.arc(u, v, uvSize, 0, 2*Math.PI);
    this.context.fill();
};

Grid.prototype.highlightPoint = function(point, color) {
    var size = 6;
    color = color || "#3F3";
    this.context.beginPath();
    this.context.strokeStyle = color;
    var uvPoint = this.transform(point);
    var u = uvPoint[0];
    var v = uvPoint[1];
    /*x, y, radius, startAngle, endAngle*/
    this.context.arc(u, v, size, 0, 2*Math.PI);
    this.context.stroke();
};

Grid.prototype.transform = function(pointXY) {
    return [pointXY[0] * this.scale + this.originU,
            pointXY[1] * -1 * this.scale + this.originV];

};

Grid.prototype.inverse = function(pointUV) {
    return [(pointUV[0] - this.originU) / this.scale,
            (this.originV - pointUV[1]) / this.scale];

};

Grid.prototype.clear = function() {
    this.context.clearRect(0, 0, this.width, this.height);
    this.drawGrid();
};

//(x1,y1) - starting coordinates
//(x2,y2) - ending coordinates
//color - color
Grid.prototype.drawStick = function(x1, y1, x2, y2, color) {
    color = color || "#33CC33";
    var ctx = this.context
    //line
    ctx.beginPath();
    ctx.strokeStyle = color;
    var start = this.transform([x1,y1]);
    var end = this.transform([x2, y2]);
    ctx.moveTo(start[0],start[1]);
    ctx.lineTo(end[0],end[1]);
    ctx.stroke();

    //dot at tip
    ctx.beginPath();
    ctx.fillStyle = color;
    /*x, y, radius, startAngle, endAngle*/
    this.context.arc(end[0], end[1], 4, 0, 2*Math.PI);
    ctx.fill();
};

//(x1,y1) - center coordinates
//r - radius
//color - color
Grid.prototype.drawCircle = function(x1, y1, r, color) {
    color = color || "#33CC33";
    var ctx = this.context
    //line
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    var center = this.transform([x1,y1]);
    ctx.arc(center[0],center[1], r * this.scale, 0, 2 * Math.PI);
    ctx.stroke();
    ctx.lineWidth = 1;
};






function Simulator(grid, gears, speed) {
    this.grid = grid;
    this.gears = gears;
    this.speed = speed || 1;
    this.reset();

    this.renderSteps = [];
    this.showPath = true;
    this.showDisks = true;

    this.renderLoop();
};

Simulator.prototype.addRenderStep = function(cb) {
    this.renderSteps.push(cb);
};

Simulator.prototype.renderLoop = function(){
    //Not re-entrant, should only be called once
    var TWO_PI = 2*Math.PI;

    var last = null;
    var sim = this;
    var step = function(now) {
        if (sim.playing) {
            if (last !== null) {
                sim.t = (sim.t + ((now - last) / 1000 * sim.speed)) % TWO_PI;
                last = now;
            }
            last = now;
        } else {
            last = null;
        }
        sim.render();

        requestAnimationFrame(step);
    }

    requestAnimationFrame(step);
}

Simulator.prototype.play = function(){
    this.playing = true;
};

Simulator.prototype.pause = function(){
    this.playing = false;
};

Simulator.prototype.step = function(dt){
    var TWO_PI = Math.PI * 2;
    this.t = (this.t + dt) % TWO_PI;
    if (this.t < 0) { this.t += TWO_PI;}
    this.render();
};

Simulator.prototype.setGears = function(gears){
    this.pause();
    this.gears = gears;
    this.reset();
    this.render();
};

Simulator.prototype.reset = function(){
    this.t = 0;
    this.playing = false;
    this.path = [];
};

Simulator.prototype.render = function() {
    this.grid.clear();
    this.renderSteps.forEach(function(cb){cb();});

    var offsetX = 0, offsetY = 0;
    var t = t || 0;
    var colors = ["#33CC33", "#CC3333", "#3333CC",
            "#0066CC", "#CC0066", "#66CC00",
            "#00CC66", "#CC6600", "#6600CC"];
    for (var i = 0; i < this.gears.length; i++) {
        var gear = this.gears[i];
        var endX = offsetX + gear[1] * Math.cos(gear[0] * this.t + gear[2]);
        var endY = offsetY + gear[1] * Math.sin(gear[0] * this.t + gear[2]);
        if (this.showDisks) {
            this.grid.drawCircle(offsetX, offsetY, gear[1], colors[i % colors.length]);
        }
        this.grid.drawStick(offsetX, offsetY, endX, endY, colors[i % colors.length]);
        offsetX = endX;
        offsetY = endY;
    }

    //Save the final point for drawing later
    this.path.push([offsetX, offsetY]);

    if (this.showPath) {
        this.drawPath();
    }
};

Simulator.prototype.drawPath = function(){
    var grid = this.grid;
    this.path.forEach(function(point) {
        grid.drawPoint(point, 1, "#A66");
    });
};







//adapted from https://github.com/andrew/base62.js/blob/master/base62.js
var base62 = {};
base62.chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
base62.encode = function(i) {
    if (i === 0) {return '0';}
    var s = '';
    while (i > 0) {
        s = this.chars[i % 62] + s;
        i = Math.floor(i/62)
    }
    return s;
};

base62.pad = function(encoded, padTo) {
    while(encoded.length < padTo) {
        encoded = '0' + encoded;
    }
    return encoded;
};

base62.decode2 = function(s) {
    var i = 0;
    var j = 0;
    while (j < s.length) {
        i += base62.chars.indexOf(s[s.length - j - 1]) * Math.pow(62, j);
        j++;
    }
    return i;
};

base62.decode = function(a, b, c, d) {
    for (
            b = c = (
                a === (/\W|_|^$/.test(a += "") || a)
                ) - 1;
            d = a.charCodeAt(c++);
        )
    b = b * 62 + d - [, 48, 29, 87][d >> 5];
    return b;
};




//GridControlsUI
//ExampleControlsUI
function ExampleControlsUI(controller, examples, defaultExample) {
    this.controller = controller;
    this.examples = examples;
    this.defaultExample = defaultExample;
}

ExampleControlsUI.prototype.render = function(){
    var p = document.createElement("p");
    var l = document.createElement("l");
    l.innerText = "Pick an Example: ";
    p.appendChild(l);

    var exampleSelect = document.createElement("select");
    var ui = this;

    exampleSelect.addEventListener("change", function(){
        var code = ui.examples[exampleSelect.value];
        if (code) {
            ui.controller.loadPointsFromCode(code);
        }
    });

    /*exampleSelect.options[0] = new Option("Custom", "Custom");
    var i = 1;
    */
    var i = 0;
    for (var name in this.examples) {
        exampleSelect.options[i++] = new Option(name, name);
        if (name == this.defaultExample) {
            exampleSelect.selectedIndex = exampleSelect.options.length - 1;
        }
    }
    p.appendChild(exampleSelect);
    return p;
};

function GridControlsUI(controller, displayConfig) {
    this.controller = controller;
    this.displayConfig = displayConfig;
}

GridControlsUI.prototype.controlsMapping = { 
    "show-grid": "showGrid",
    "show-axes": "showAxes",
    "show-points": "showPoints",
    "show-path": "showPath",
    "show-disks": "showDisks",
};
GridControlsUI.prototype.labelsMapping = { 
    "show-grid": "Show Grid",
    "show-axes": "Show Axes",
    "show-points": "Show Points",
    "show-path": "Show Path",
    "show-disks": "Show Disks",
};

GridControlsUI.prototype.showGrid = function(show){
    this.controller.grid.showGrid = show;
};

GridControlsUI.prototype.showAxes = function(show){
    this.controller.grid.showAxes = show;
};

GridControlsUI.prototype.showPath = function(show){
    this.controller.sim.showPath = show;
};

GridControlsUI.prototype.showDisks = function(show){
    this.controller.sim.showDisks = show;
};

GridControlsUI.prototype.showPoints = function(show){
    this.controller.showPoints = show;
};

GridControlsUI.prototype.render = function(){
    var container = document.createElement("div");

    var checkboxes = document.createElement("div");
    checkboxes.className = "checkbox-controls";
    var actionFor = function(ui, domId) {
        var fnName = ui.controlsMapping[domId];
        var action = ui[fnName] || function(){};
        return function(){action.call(ui, this.checked);};
    }

    for (var prop in this.controlsMapping) {
        //need closure to bind prop variable
        checkboxes.appendChild(this.renderCheckbox(prop, actionFor(this, prop)));
    }
    container.appendChild(checkboxes);

    container.appendChild(this.renderDiskSelect());
    return container;
};

GridControlsUI.prototype.renderCheckbox = function(prop, onChange){
    var id = this.displayConfig.name + "-" + prop;
    var p = document.createElement("p");
    var l = document.createElement("label");

    l.setAttribute("for", id);
    l.innerText = this.labelsMapping[prop];
    var i = document.createElement("input");
    i.setAttribute("type", "checkbox");
    i.id = id;

    if (this.displayConfig[this.controlsMapping[prop]]) {
        i.setAttribute("checked", "checked");
    }

    i.addEventListener("change", onChange);

    p.appendChild(l);
    p.appendChild(i);
    return p;
};

GridControlsUI.prototype.renderDiskSelect = function(){
    var p = document.createElement("p");
    var l = document.createElement("l");
    l.innerText = "Maximum number of disks:";
    p.appendChild(l);

    //TODO: update gear select when # of points change
    var gearSelect = document.createElement("select");
    var defaultSelection = this.displayConfig.points.length;
    for (var i = 1; i <= this.displayConfig.points.length; i++) {
        var option = document.createElement("option");
        option.innerText = i;
        option.value = i;
        if (i == defaultSelection) {
            option.setAttribute("selected", "selected");
        }
        gearSelect.appendChild(option);
    }

    var ui = this;
    gearSelect.addEventListener("change", function(){
        ui.controller.numberOfGears = parseInt(gearSelect.value, 10);
        ui.controller.refreshSim();
    });
    p.appendChild(gearSelect);
    return p;
};





/*Renders the epicycle grid, simulator, and controls based on a div element like:
<div class="example epicycle-display" id="circle" data-points="600000400000"
    data-simulator-controls="true" data-grid-controls="true" data-show-grid="false" data-show-points="false">
</div>
*/
function GridDisplay(config) {
    var config = config || {};
    this.rendered = false;

    var getDefault = function(obj, base, param, fallback) {
        obj[param] = base[param] !== undefined ? base[param] : fallback;
    }

    this.config = {};
    getDefault(this.config, config, "name", "default");
    getDefault(this.config, config, "points", []);
    getDefault(this.config, config, "showGridControls", true);
    getDefault(this.config, config, "showSimulatorControls", true);
    getDefault(this.config, config, "showShareControls", false);
    getDefault(this.config, config, "showGrid", true);
    getDefault(this.config, config, "showAxes", true);
    getDefault(this.config, config, "showPoints", true);
    getDefault(this.config, config, "showPath", true);
    getDefault(this.config, config, "showDisks", true);
    getDefault(this.config, config, "editable", true);
    getDefault(this.config, config, "autoplay", true);
    getDefault(this.config, config, "width", 600);
    getDefault(this.config, config, "height", 500);
    getDefault(this.config, config, "numGears", 10);
    getDefault(this.config, config, "scale", 70);
}

GridDisplay.prototype.loadAndRenderInto = function(elem) {
    this.load(elem);
    elem.appendChild(this.render());
};

GridDisplay.prototype.load = function(elem) {
    var mapping = {
        "grid-controls": "showGridControls",
        "simulator-controls": "showSimulatorControls",
        "share-controls": "showShareControls",
        "show-grid": "showGrid",
        "show-axes": "showAxes",
        "show-points": "showPoints",
        "show-path": "showPath",
        "show-disks": "showDisks",
        "editable": "editable",
        "autoplay": "autoplay",
        "name": "name",
        "width": "width",
        "height": "height",
        "num-gears": "numGears",
        "scale": "scale",
    }
    var config = this.config;

    var loadAttribute = function(attr) {
        var lookup = "data-" + attr;
        if (elem.hasAttribute(lookup)) {
            //mutate in place
            config[mapping[attr]] = elem.getAttribute(lookup);
        }
    };

    var loadBooleanAttribute = function(attr) {
        var lookup = "data-" + attr;
        if (elem.hasAttribute(lookup)) {
            //mutate in place
            config[mapping[attr]] = elem.getAttribute(lookup) === "true";
        }
    };

    for (var attr in mapping) {
        loadBooleanAttribute(attr);
    }

    loadAttribute("name");
    loadAttribute("width");
    this.config.width = parseInt(this.config.width, 10);
    loadAttribute("height");
    this.config.height = parseInt(this.config.height, 10);
    loadAttribute("num-gears");
    loadAttribute("scale");

    if (elem.hasAttribute("data-points")) {
        this.config.points = this.parsePoints(elem.getAttribute("data-points"));
    }
};

GridDisplay.prototype.parsePoints = function(string) {
    var points = [];
    string = string.replace(/\s/g,'');
    for (var i = 0; i <= string.length - 6; i += 6) {
        digits = string.slice(i, i + 6);
        var X = Math.floor(digits/1000);
        var Y = digits % 1000;
        points.push([(X - 500)/100, (Y - 500)/100]);
    }
    return points;
}

GridDisplay.prototype.render = function() {
    var curr = this;
    var container = document.createElement("div");
    container.className = "applet-container";
    container.style.width = this.config.width + "px";
    container.style.height = this.config.height + "px";
    console.log(container.style.height);

    var canvas = document.createElement("canvas");
    canvas.className = "slate";
    canvas.width = this.config.width;
    canvas.height = this.config.height;
    canvas.innerText = "Your browser doesn't support canvas, try using a more up-to-date browser.";

    var scale = parseInt(this.config.scale, 10);
    var grid = new Grid(canvas, scale);
    grid.showGrid = this.config.showGrid;
    grid.showAxes = this.config.showAxes;

    var numberOfGears = parseInt(this.config.numGears, 10);
    console.log(this.config);
    controller = new GridController(grid, this.config.points, numberOfGears, this.config.editable);
    controller.sim.showPath = this.config.showPath;
    controller.showPoints = this.config.showPoints;

    if (this.config.showGridControls) {
        var gridControls = this.createGridControls(controller);
        container.appendChild(gridControls);
        container.style.width = (this.config.width + 200) + "px";
    }

    var simContainer = document.createElement("div");
    simContainer.className = "sim-container";
    simContainer.style.width = this.config.width + "px";

    simContainer.appendChild(canvas);
    container.appendChild(simContainer);

    if (this.config.showSimulatorControls) {
        var simControls = this.createSimulatorControls(controller.sim);
        simContainer.appendChild(simControls);

        controller.sim.addRenderStep(function(){
            if (controller.sim.playing) {
                curr.simulator.slider.setValue(controller.sim.t / (2 * Math.PI) * 100);
            }
        });
        container.style.height = (this.config.height + 80) + "px";
    }

    if (this.config.showShareControls) {
        var shareControls = this.createShareControls(controller);
        container.appendChild(shareControls);
        container.style.height = (this.config.height + 80) + "px";
    }

    controller.refreshSim(this.config.autoplay);
    return container;
}

GridDisplay.prototype.createGridControls = function(controller){
    var gridControls = document.createElement("div");
    gridControls.className = "grid-controls";

    var examples = {
        "Flower": "2Weo26cA26fO26cA1gaM26cA269m26cA",
        "Straight Line": "26ec26cA26aY26cA",
        "Square": "2wf62wdu2wbS26aY1Ga41GbG1Gdi26ec",
        "Plus Sign": "26ec26do26cA2jd22wdu2jd226cA26bM26aY26bM26cA1Tc81GbG1Tc826cA26do",
        "Letter B": "1SbS2dgj2m5B2hoo26sJ2iql2nm52cVW1TWu1RDm",
        "Blank": "0",
    };
    var defaultExample = "Square";
    var examplesUi = new ExampleControlsUI(controller, examples, defaultExample);
    gridControls.appendChild(examplesUi.render());

    var ui = new GridControlsUI(controller, this.config);
    gridControls.appendChild(ui.render());

    return gridControls;
}

GridDisplay.prototype.createShareControls = function(controller) {
    var shareControls = document.createElement("div");
    shareControls.className = "share-controls";

    var shareButton = document.createElement("button");
    shareButton.innerText = "Get a link to this drawing";

    var shareLink = document.createElement("a");
    shareLink.innerText = "Link";
    shareLink.setAttribute("target","_blank");
    shareLink.style.display = "none";

    shareButton.innerText = "Get a link to this drawing";
    shareButton.addEventListener("click", function(){
        var code = controller.getCodeForPoints();
        var href = window.location.protocol + "//" + 
                    window.location.host + window.location.pathname + "#" + code;
        shareLink.setAttribute("href", href);
        shareLink.textContent = href;
        shareLink.style.display = "inline";
    });
    shareControls.appendChild(shareButton);
    shareControls.appendChild(shareLink);
    return shareControls
};

GridDisplay.prototype.createSimulatorControls = function(sim) {
    var simControls = document.createElement("div");
    simControls.className = "simulator-controls";

    this.simulator = {};

    var createElement = function(type, className, text) {
        var e = document.createElement(type);
        e.className = className;
        if (text) {
            e.innerText = text;
        }
        return e;
    }

    var slider = createElement("div", "slider");
    var sliderBar = createElement("div", "slider-bar");
    var sliderButton = createElement("div", "slider-button");
    slider.appendChild(sliderBar);
    slider.appendChild(sliderButton);

    simControls.appendChild(slider);
    this.simulator.slider = this.createSlider(slider, {
        onchange: function(percent) {
            sim.pause();
            sim.t = Math.PI * 2 * percent / 100;
            sim.render();
            setPlayState(false);
        }
    });

    var buttons = createElement("div", "buttons");

    var stepBack = createElement("button", "", "Step Back");
    var pausePlay = createElement("button", "pause", "Pause");
    var stepForward = createElement("button", "", "Step Forward");
    var fastForward = createElement("button", "", "Fast Forward");

    buttons.appendChild(stepBack);
    buttons.appendChild(pausePlay);
    buttons.appendChild(stepForward);
    buttons.appendChild(fastForward);

    var getPlayState = function() {
        return pausePlay.className.indexOf("pause") >= 0;
    };

    var setPlayState = function(play) {
        //button is opposite of what is currently occuring (i.e. show pause button
        //when playing, play button when paused)
        if (play) {
            pausePlay.textContent = "Pause";
            pausePlay.className = pausePlay.className.replace("play", "pause");
        } else {
            pausePlay.textContent = "Play";
            pausePlay.className = pausePlay.className.replace("pause", "play");
        }
    };
    setPlayState(this.config.autoplay);
    
    var curr = this;
    var actions = {
        play: function(){sim.speed = 1; sim.play();},
        pause: function(){sim.pause();},
        stepForward: function(){
            sim.pause();
            sim.step(.1);
            curr.simulator.slider.setValue(sim.t / (2 * Math.PI) * 100);
        },
        stepBackward: function(){
            sim.pause();
            sim.step(-.1);
            curr.simulator.slider.setValue(sim.t / (2 * Math.PI) * 100);
        },
        fastForward: function() {
            sim.speed *= 1.5;
            sim.play();
        }
    };

    pausePlay.addEventListener("click", function(){
        var playing = getPlayState();

        if (playing) {
            actions.pause();
            setPlayState(false);
        } else {
            actions.play();
            setPlayState(true);
        }
    });
    stepForward.addEventListener("click", function(){
        actions.stepForward();
        setPlayState(false);
    });
    stepBack.addEventListener("click", function(){
        actions.stepBackward();
        setPlayState(false);
    });

    fastForward.addEventListener("click", function(){
        actions.fastForward();
        setPlayState(true);
    });

    simControls.appendChild(buttons);
    return simControls;
};

GridDisplay.prototype.createSlider = function(element, options) {
    var bar = element.querySelector(".slider-bar");
    var button = element.querySelector(".slider-button");
    var dragging = false;
    var onchange = options.onchange || function(){};

    var moveToClientX = function(clientX) {
        var oLeft = element.offsetLeft, width = element.offsetWidth;
        setValue((clientX - oLeft) / width * 100, true);
    };
    var setValue = function(percent, do_callback) {
        percent = Math.max(0, Math.min(percent, 100));
        button.style.left = percent + "%";
        if (do_callback) { onchange.call(element, percent); }
    };

    element.addEventListener("mousedown", function(e) {
        dragging = true;
        moveToClientX(e.clientX);
    });
    window.addEventListener("mouseup", function(e) {
        dragging = false;
    });
    window.addEventListener("mousemove", function(e) {
        if (dragging) { moveToClientX(e.clientX); }
    });

    return {
        setValue: setValue
    }
};



/*Listens for and handles UI Interactions with the grid*/
function GridController(grid, points, numberOfGears, editable) {
    this.grid = grid;
    this.points = points;
    this.numberOfGears = numberOfGears;
    this.sim = new Simulator(grid, [], 1);
    this.changeHandlers = [];
    this.editable = editable !== undefined ? !!editable : true;

    this.showPoints = true;

    var gc = this;
    this.sim.addRenderStep(function(){
        if (gc.showPoints) {
            gc.drawPoints();
            gc.highlightPoints();
        }
    });

    //I don't want to make points into objects, so I keep their state in
    //a separate array. A bit hacky.
    this.pointState = [];
    this.points.forEach(function(point, i){
        gc.pointState[i] = {highlighted: false};
    });

    if (this.editable) {
        this.grid.canvas.addEventListener("mousemove", function(e){ gc.mouseMove(e) });
        this.grid.canvas.addEventListener("mousedown", function(e){
            gc.setDragging(true);
        });
        this.grid.canvas.addEventListener("contextmenu", function(e){
            e.preventDefault();
            gc.rightClick(e);
            return false;
        });
        window.addEventListener("mouseup", function(e){ 
            gc.setDragging(false);
        });
        this.grid.canvas.addEventListener("dblclick", function(e){ gc.dblclick(e) });
    }
}

GridController.prototype.addPointsChangedHandler = function(handler) {
    this.changeHandlers.push(handler);
};

GridController.prototype.getCodeForPoints = function(code) {
    //Turn the array of points into a minimally sized string
    //Algorithm:
    //Every point is a pair of floats, (X,Y). Due to the grid size,
    //We know every X and Y is -5 < X < 5
    //Also, due to the accuracy of clicking and dragging, more than
    //two significant figures is probably unnecessary. Therefore,
    //we can model each X (or Y) as three digits, A, B, and C (each 0-9) such that
    //X = (A - 5) + B/10 + C/100. Thus each pair is 6 digits. We append
    //All these 6 digit numbers together without separators, and 
    //base62 encode (A-Za-z0-9). In this way, 10 points = 20 floats
    //= 60 digits. log_62(10^60) = log_10(10^60)/log_10(62) = 60/log_10(62)
    // = 60 * .55 ~= 30 characters. If we instead used just toString(),
    //assuming a float is 8 charaters and we use commas and brackets,
    //we'd be at ~20 characters per point or 200 characters. So we compress
    //by ~6-7x
    //Adendum: Because javascript numbers can't hold arbitrarily
    //large precision, we actually just base62 encode each set of 6 digits
    //and pad out to 4 characters. Less compression by a bit, but easier
    //to deal with
    var points = this.points;
    var result = "";
    points.forEach(function(point){
        var X = (point[0] + 5).toFixed(2); //X is a string
        var Y = (point[1] + 5).toFixed(2); //Y is a string
        var digits = (X + Y).replace(/\./g, '');
        result += base62.pad(base62.encode(digits * 1), 4); //convert to #
    });
    return result;
}

GridController.prototype.loadPointsFromCode = function(code) {
    if (!code) {return;}

    this.points = [];
    for (var i = 0; i <= code.length - 4; i += 4) {
        var digits = base62.decode(code.slice(i, i + 4));
        var X = Math.floor(digits/1000);
        var Y = digits % 1000;
        this.points.push([(X - 500)/100, (Y - 500)/100]);
    }
    this.pointsChanged();
};

GridController.prototype.pointsChanged = function(handler) {
    var self = this;
    this.points.forEach(function(point, i){
        self.pointState[i] = {highlighted: false};
    });
    this.changeHandlers.forEach(function(handler){handler(self.points);});
    this.refreshSim();
};

GridController.prototype.refreshSim = function(play) {
    var play = play !== undefined ? !!play : false;

    var gears = [];
    if (this.points.length > 0) {
        var gears = epicycles.calculateGears(this.points, this.numberOfGears);
    }

    var self = this;
    var wasPlaying = this.sim.playing;
    console.log("Was playing", wasPlaying, "autoplay", play);
    this.sim.setGears(gears);
    //controls.simulator.slider.setValue(0);
    if (play || wasPlaying) {
        setTimeout(function(){
            self.sim.play();
        }, 5);
    }
};

/*Events*/
GridController.prototype.setDragging = function(dragging) {
    if (dragging === !!this.dragging) {
        return;
    }
    this.dragging = dragging;
    //if we started dragging, pause
    //if we stopped dragging, refresh points
    if (this.dragging) {
        this.pausedStateToDrag = this.sim.playing;
    }

    if (!this.dragging) {
        if (this.pointsChangedWhileDragging) {
            this.refreshSim(this.pausedStateToDrag);
            this.pointsChangedWhileDragging = false;
        } else {
            if (this.pausedStateToDrag) {
                this.sim.play();
            }
            this.pausedStateToDrag = false;
        }
    }
};

GridController.prototype.rightClick = function(e) {
    //remove whatever is highlighted
    var self = this;
    var deletedPoint = this.points.some(function(point, i) {
        if (self.pointState[i].highlighted) {
            //remove the point
            self.points.splice(i, 1);
            self.pointState.splice(i, 1);
            return true;
        }
        return false;
    });
    if (deletedPoint) {
        this.pointsChanged();
    }
};

GridController.prototype.mouseMove = function(e) {
    if (!this.showPoints) {
        return;
    }

    var pointXY = this.eventToXY(e);
    var self = this;
    if (this.dragging) {
        //find first highlighted point, move it
        //some, unlike forEach, quits when it gets a true
        var gc =this;
        this.points.some(function(point, i) {
            if (self.pointState[i].highlighted) {
                self.sim.pause();
                point[0] = pointXY[0];
                point[1] = pointXY[1];
                self.pointsChangedWhileDragging = true;
                return true;
            }
            return false;
        });
    } else {
        this.points.some(function(point, i){
            if (!self.pointState[i]) {return false;}

            if (self.doPointsOverlap(pointXY, point)) {
                self.pointState[i].highlighted = true;
            } else {
                self.pointState[i].highlighted = false;
            }
            return self.pointState[i].highlighted;
        });
    }
};

GridController.prototype.dblclick = function(e) {
    var pointXY = this.eventToXY(e);
    //edge case: points array is <= 1 element
    if (this.points.length <= 1) {
        this.points.push(pointXY);
        this.pointState.push({highlighted: true});
    } else {
        //add point next to nearest neighbor. Whether adding before or after
        //depends on what the new point is "between"
        var nearest = this.nearestPoints(pointXY);
        var near_index = this.points.indexOf(nearest[0]);
        var before_index = (near_index + this.points.length - 1) % this.points.length;
        var after_index = (near_index + 1) % this.points.length;

        //Call the nearest point N, the one before B, the one after A, and where we clicked X.
        //We want to determine if X is "between" B and N, or "between" N and A
        //I use quotes because we're not looking for colinear, but instead what's expected
        //by the user as "closer". We can't actually use linear distance either, because
        //we could be colinear with B and N, but N and A are close together, so we're closer to A
        //The best way to calculate if X is "between" B and N vs N and A is determination of
        //angles. If Angle(B-X-N) > (N-X-A), we're between B and N, and visa-versa.
        //We calculate using dot products, given cos(theta) = (a * b)/(|a||b|)
        //We won't have anything > 180, so greater angle means smaller cosine
        //so we flip the > sign and don't take the arccos
        //Since we use XN in both, we don't need to divide by |N|, so we get
        //put_before = (XB*XN)/|XB| < (XA*XN)/|XA|
        var B = this.points[before_index];
        var N = nearest[0];
        var A = this.points[after_index];
        var XB = [B[0] - pointXY[0], B[1] - pointXY[1]];
        var XN = [N[0] - pointXY[0], N[1] - pointXY[1]];
        var XA = [A[0] - pointXY[0], A[1] - pointXY[1]];
        var cos_bxn = (XB[0]*XN[0] + XB[1]*XN[1])/Math.sqrt(XB[0]*XB[0]+XB[1]*XB[1]);
        var cos_axn = (XA[0]*XN[0] + XA[1]*XN[1])/Math.sqrt(XA[0]*XA[0]+XA[1]*XA[1]);

        var put_before = cos_bxn < cos_axn;
        if (put_before) {
            this.points.splice(near_index, 0, pointXY);
            //yuck
            this.pointState.splice(near_index, 0, {highlighted: true});
        } else {
            //We actually want to go after, as it feels more natural when editing
            //than putting the new point at the beginning
            this.points.splice(near_index + 1, 0, pointXY);
            this.pointState.splice(near_index + 1, 0, {highlighted: true});
        }
    }

    this.pointsChanged();
};

GridController.prototype.drawPoints = function() {
    var grid = this.grid;
    this.points.forEach(function(point, i) {
        grid.drawLabeledPoint(point, i + 1);
    });
};

GridController.prototype.highlightPoints = function() {
    var grid = this.grid;
    var self = this;
    this.points.forEach(function(point, i) {
        if (i in self.pointState && self.pointState[i].highlighted) {
            grid.highlightPoint(point);
        }
    });
};

/*Utilities*/
GridController.prototype.eventToXY = function(e) {
    var x = e.pageX - this.grid.canvas.offsetLeft;
    var y = e.pageY - this.grid.canvas.offsetTop;
    return this.grid.inverse([x, y]);
};

GridController.prototype.doPointsOverlap = function(point1, point2, epsilon) {
    var epsilon = epsilon || 6 / this.grid.scale;
    //just do square hitbox testing, no reason to get squareroots involved
    return Math.abs(point1[0] - point2[0]) <= epsilon &&
        Math.abs(point1[1] - point2[1]) <= epsilon;
};

GridController.prototype.nearestPoints = function(test_point) {
    //copy points, sort based on distance
    var copy = this.points.slice();
    var gc = this;
    copy.sort(function(a, b) {
        return gc.compareDistance(test_point, a, b);
    });
    return copy;
};

//Returns a negative number if test_point is closer to a then b, else a positive number. 0 if
//same distance
GridController.prototype.compareDistance = function(test_point, a, b) {
    var a_dx = a[0] - test_point[0];
    var a_dy = a[1] - test_point[1];
    var b_dx = b[0] - test_point[0];
    var b_dy = b[1] - test_point[1];
    //comparing, no need to sqrt
    return (a_dx*a_dx + a_dy*a_dy) - (b_dx*b_dx + b_dy*b_dy);
};








// INDEX

document.addEventListener("DOMContentLoaded", function(event) {
    var examples = document.querySelectorAll(".example");
    for (var i = 0; i < examples.length; i++) {
        var display = new GridDisplay();
        display.loadAndRenderInto(examples[i]);
    }
});
            
</script>